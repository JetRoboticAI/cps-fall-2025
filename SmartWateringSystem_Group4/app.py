"""


Key behaviors:
- auto_watering(): runs one immediate cycle right after AUTO is enabled, then runs
  every LOG_PERIOD_SEC seconds (default 120s). The scheduler aligns to boundaries
  measured from local midnight (00:00) to prevent drift across long runtimes.
- /read_and_log: retained; can be used by the frontend to manually trigger a single
  sensor read and a database write (no watering).
- All database timestamps are generated by iso_now_local() (local timezone + offset,
  e.g., 2025-10-19T09:00:00+08:00).
- Other APIs/behaviors unchanged (per-plant thresholds, manual pump control, etc.).
"""

from flask import Flask, render_template, jsonify, request, send_from_directory
import sys
import threading
import time
import atexit
import os
import json
import datetime as dt
from urllib import request as urlreq
from urllib import error as urlerr

from sensor import Sensor
from pump import Pump
from hold import PumpHoldManager

# ------------ configuration ------------
CONFIG_PATH = "config.json"


def load_config(path=CONFIG_PATH):
    """Load JSON config from disk. Returns an empty dict on failure."""
    try:
        with open(path, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"[config] load failed: {e}")
        return {}


def save_config(config, path=CONFIG_PATH):
    """Persist JSON config to disk. Logs an error if the write fails."""
    try:
        with open(path, "w") as f:
            json.dump(config, f, indent=2)
        print(f"[config] Saved to {path}")
    except Exception as e:
        print(f"[config] Save error: {e}")


cfg = load_config()

AVG_READINGS = cfg.get("AVG_READINGS", 4)
THRESHOLD = cfg.get("THRESHOLD", 20)                 
AUTO_WATER_SEC = cfg.get("AUTO_WATER_SEC", 1)
PORT = cfg.get("PORT", 1234)
AUTO_ENABLED = bool(cfg.get("AUTO_ENABLED", True))
PLANT_THRESHOLDS = cfg.get("PLANT_THRESHOLDS", None)

# To set auto-watering period.
LOG_PERIOD_SEC = int(cfg.get("LOG_PERIOD_SEC", 120))

# Pump sequencing behavior for auto-watering actions:
SERIAL_WATERING = True           # If True, water zones sequentially; otherwise attempt parallel starts.
INTER_ZONE_COOLDOWN_SEC = 1.0    # Cooldown between two pumps when SERIAL_WATERING is True.
WAIT_POLL_INTERVAL = 0.1         # Poll interval when waiting for a pump to finish.
MAX_WAIT_PAD_SEC = 5.0           # Extra wait cap to avoid indefinite blocking.

# ------------ hardware instances ------------
sensor_devices = [Sensor(**s_conf) for s_conf in cfg.get("SENSORS", [])]
pumps = [Pump(**p_conf) for p_conf in cfg.get("PUMPS", [])]

# -------- Firebase (server-side write target) --------
FIREBASE_DB_BASE = cfg.get(
    "FIREBASE_DB_BASE",
    "https://watersystem-707cf-default-rtdb.firebaseio.com/"
).rstrip("/")


def iso_now_local():
    """Return ISO string with local timezone offset: YYYY-MM-DDTHH:MM:SSÂ±HH:MM."""
    return dt.datetime.now().astimezone().replace(microsecond=0).isoformat()


def _http_json_get(path):
    """
    GET a Firebase path (relative to DB root) and return a Python object or None.

    """
    url = f"{FIREBASE_DB_BASE}/{path}.json"
    req = urlreq.Request(url, method="GET", headers={"Cache-Control": "no-store"})
    try:
        with urlreq.urlopen(req, timeout=10) as resp:
            data = resp.read()
            if not data:
                return None
            return json.loads(data.decode("utf-8"))
    except urlerr.URLError as e:
        print(f"[firebase] GET {path} failed: {e}")
        return None


def _http_json_put(path, body):
    """
    PUT a Firebase path with a JSON body.
    Returns the decoded response or None on failure.
    """
    url = f"{FIREBASE_DB_BASE}/{path}.json"
    payload = json.dumps(body).encode("utf-8")
    req = urlreq.Request(url, data=payload, method="PUT",
                         headers={"Content-Type": "application/json"})
    try:
        with urlreq.urlopen(req, timeout=10) as resp:
            data = resp.read()
            return json.loads(data.decode("utf-8")) if data else None
    except urlerr.URLError as e:
        print(f"[firebase] PUT {path} failed: {e}")
        return None


def _firebase_append_array(path, item):
    """
    Append an item to a Firebase array structure that mirrors the frontend history:
      1) Read current value at 'path'
      2) Compute next numeric index (list length or max(dict keys) + 1)
      3) PUT the item to '<path>/<index>.json'
    
    """
    arr = _http_json_get(path)
    if isinstance(arr, list):
        next_index = len(arr)
    elif isinstance(arr, dict) and arr:
        keys = []
        for k in arr.keys():
            try:
                n = int(k)
                if n >= 0:
                    keys.append(n)
            except Exception:
                pass
        next_index = (max(keys) + 1) if keys else 0
    else:
        _http_json_put(path, [])
        next_index = 0

    _http_json_put(f"{path}/{next_index}", item)


# ------------ per-plant thresholds (persisted in config.json) ------------
SENSOR_COUNT = len(sensor_devices)


def _normalize_thresholds_in_cfg():
    """
    Ensure cfg['PLANT_THRESHOLDS'] exists and has the same length as the sensor count.
    If missing, invalid, or length mismatched, fill with the global THRESHOLD and persist.
    Returns the normalized list.
    """
    pts = cfg.get("PLANT_THRESHOLDS")
    base_val = float(cfg.get("THRESHOLD", 20))
    base = [base_val] * SENSOR_COUNT

    if isinstance(pts, list) and len(pts) > 0:
        for i in range(min(SENSOR_COUNT, len(pts))):
            try:
                base[i] = float(pts[i])
            except Exception:
                base[i] = base_val
    cfg["PLANT_THRESHOLDS"] = base
    try:
        save_config(cfg)
    except Exception as e:
        print(f"[config] write PLANT_THRESHOLDS failed: {e}")
    return base


# One-to-one mapping with sensors: index 0 -> plant 1, etc.
PLANT_THRESHOLDS = _normalize_thresholds_in_cfg()

# ------------ global state ------------
last_pct = [None] * len(sensor_devices)  # Last cached readings prior to any pump activation
_state_lock = threading.Lock()           # Protects shared mutable state across threads
_pump_active_evt = threading.Event()     # Indicates whether any pump is currently active
_active_pump_count = 0                   # Number of currently active pumps
_auto_enabled_evt = threading.Event()    # Tracks auto-watering enabled state
if AUTO_ENABLED:
    _auto_enabled_evt.set()
else:
    _auto_enabled_evt.clear()


# ------------ non-public state transition helpers ------------
def _begin_pump():
    """Mark that a pump is starting; increments active count and sets the active event."""
    global _active_pump_count
    with _state_lock:
        _active_pump_count += 1
        _pump_active_evt.set()


def _end_pump():
    """Mark that a pump is ending; decrements active count and clears the event if zero."""
    global _active_pump_count
    with _state_lock:
        _active_pump_count = max(0, _active_pump_count - 1)
        if _active_pump_count == 0:
            _pump_active_evt.clear()


# Unified hold manager that abstracts pump on/off with optional timing and mutual exclusion
hold = PumpHoldManager(pumps, on_begin=_begin_pump, on_end=_end_pump)


def _seed_cache():
    """
    Read initial sensor values at process start and populate 'last_pct'.
    This improves API responsiveness if an early read fails by providing a fallback.
    """
    global last_pct
    pct = []
    for s in sensor_devices:
        try:
            pct.append(round(s.get_humidity(AVG_READINGS), 1))
        except Exception as e:
            pct.append(None)
            print(f"[boot] seed read failed: {e}", file=sys.stderr)
    with _state_lock:
        last_pct[:] = pct


def _cleanup():
    """Release hardware resources at exit (off all holds, destroy pumps)."""
    try:
        hold.off_all(source="cleanup")
    except Exception as e:
        print(f"[cleanup] hold off_all err: {e}")

    for p in pumps:
        try:
            p.destroy()
        except Exception as e:
            print(f"\n[cleanup] pump destroy err: {e}")
    print("\n[cleanup] GPIO released.")


# ------------ helpers: 2-minute boundary alignment & logging ------------
def _seconds_until_next_period(period_sec: int, now: dt.datetime | None = None) -> float:
    """
    Compute seconds until the next aligned period boundary (relative to local midnight).
    This prevents timer drift: runs happen at 00:00 + n*period_sec.
    If called exactly at a boundary, return one full period to avoid immediate reruns.
    """
    if now is None:
        now = dt.datetime.now()
    midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
    elapsed = (now - midnight).total_seconds()
    remainder = elapsed % period_sec
    wait = period_sec - remainder
    if wait <= 0.001:
        wait = float(period_sec)
    return wait


def _sleep_with_enable_check(seconds: float, step: float = 5.0):
    """
    Sleep in small steps, returning early if auto-watering is turned OFF during the wait.
    This keeps the loop responsive to user changes.
    """
    remaining = float(seconds)
    while remaining > 0:
        if not _auto_enabled_evt.is_set():
            return
        t = min(step, remaining)
        time.sleep(t)
        remaining -= t


def _firebase_log_readings(percent_list):
    """
    Log current humidity readings for each plant into Firebase:
      history/plant_1..N  append [ISO(local tz), pct, should_water]
    - 'should_water' is computed by comparing pct with the per-plant threshold.
    - Missing readings (None) are skipped.
    """
    if not FIREBASE_DB_BASE:
        print("[firebase] skipped: FIREBASE_DB_BASE not set")
        return
    ts = iso_now_local()
    for i, h in enumerate(percent_list):
        if h is None:
            continue
        with _state_lock:
            thr = float(PLANT_THRESHOLDS[i]) if i < len(PLANT_THRESHOLDS) else float(THRESHOLD)
        should = (h < thr)
        path = f"history/plant_{i+1}"
        item = [ts, round(float(h), 1), bool(should)]
        try:
            _firebase_append_array(path, item)
        except Exception as e:
            print(f"[firebase] append failed @{path}: {e}")


# ------------ auto-watering: read/decide/log/water loop ------------
def _get_humidity_with_retries(sensor: Sensor, retries: int = 3, delay_sec: float = 1.0) -> float:
    """
    Try reading humidity multiple times, sleeping 'delay_sec' between attempts.
    Raises the last error if all attempts fail.
    """
    last_err = None
    for attempt in range(retries):
        try:
            return float(sensor.get_humidity(AVG_READINGS))
        except Exception as e:
            last_err = e
            print(f"[auto] sensor read err @ {getattr(sensor, 'channel', '?')} (attempt {attempt + 1}): {e}")
            time.sleep(delay_sec)
    raise last_err if last_err else Exception("unknown sensor read error")


def _run_one_auto_cycle():
    """
    One cycle of auto-watering:
      1) Read all sensors with retry.
      2) Decide per-plant whether watering is needed (pct < threshold).
      3) Log readings to Firebase (regardless of watering decisions).
      4) If auto is enabled, water needed zones (sequentially or in parallel).
    """
    to_water = []
    pct_now = []

    # --- read sensors ---
    for i, sensor in enumerate(sensor_devices):
        try:
            humidity = _get_humidity_with_retries(sensor, retries=3, delay_sec=1.0)
            pct_now.append(round(humidity, 1))
            with _state_lock:
                thr = float(PLANT_THRESHOLDS[i]) if i < len(PLANT_THRESHOLDS) else float(THRESHOLD)
            print(f"[auto] Sensor {i + 1} humidity: {humidity:.1f}% (thr={thr:.1f}%)")
            if humidity < thr:
                to_water.append(i)
        except Exception as e:
            pct_now.append(None)
            print(f"[auto] sensor read err @ {i + 1}: {e}")

    # Update cache used by APIs/fallbacks
    with _state_lock:
        for i in range(min(len(last_pct), len(pct_now))):
            last_pct[i] = pct_now[i]

    # --- log to Firebase (always) ---
    try:
        _firebase_log_readings(pct_now)
    except Exception as e:
        print(f"[auto] firebase log err: {e}")

    # --- water if needed and still enabled ---
    if not to_water or not _auto_enabled_evt.is_set():
        return

    if SERIAL_WATERING:
        # Water zones one by one; wait for each to finish (with a safety cap)
        for idx in to_water:
            if not _auto_enabled_evt.is_set():
                print("[auto] disabled mid-cycle; stop queuing new zones")
                break
            try:
                mode = hold.hold(idx, AUTO_WATER_SEC, source="auto")
                print(f"[auto] hold zone={idx + 1} {AUTO_WATER_SEC}s ({mode})")
                t_deadline = time.monotonic() + AUTO_WATER_SEC + MAX_WAIT_PAD_SEC
                while hold.is_on(idx) and time.monotonic() < t_deadline:
                    time.sleep(WAIT_POLL_INTERVAL)
            except Exception as e:
                print(f"[auto] hold err @ zone {idx + 1}: {e}")
            finally:
                time.sleep(INTER_ZONE_COOLDOWN_SEC)
    else:
        # Fire-and-forget (no sequential waiting); best-effort start for each needed zone
        for idx in to_water:
            try:
                mode = hold.hold(idx, AUTO_WATER_SEC, source="auto")
                print(f"[auto] hold zone={idx + 1} {AUTO_WATER_SEC}s ({mode})")
            except Exception as e:
                print(f"[auto] hold err @ zone {idx + 1}: {e}")


def auto_watering():
    """
    Main loop for auto-watering aligned to LOG_PERIOD_SEC boundaries:
      - When AUTO is enabled (either at boot or via API), run one cycle immediately.
      - Then compute time until the next aligned boundary since midnight and sleep.
      - On each boundary (if still enabled), run one cycle and repeat.
      - While disabled, the loop idles in short sleeps and does not read/log/water.
    """
    did_initial_run_after_enable = False

    while True:
        # Wait for AUTO to be enabled
        if not _auto_enabled_evt.is_set():
            did_initial_run_after_enable = False
            time.sleep(0.5)
            continue

        # Perform a one-time immediate cycle after AUTO becomes enabled
        if not did_initial_run_after_enable:
            print("[auto] enabled -> run immediate cycle")
            try:
                _run_one_auto_cycle()
            finally:
                did_initial_run_after_enable = True

        # Align to the next LOG_PERIOD_SEC boundary (default 120s)
        sec = _seconds_until_next_period(LOG_PERIOD_SEC)
        next_run = dt.datetime.now() + dt.timedelta(seconds=sec)
        print(f"[auto] next periodic run at {next_run.strftime('%Y-%m-%d %H:%M:%S')} (every {LOG_PERIOD_SEC}s)")
        _sleep_with_enable_check(sec)

        # If still enabled, run one cycle
        if _auto_enabled_evt.is_set():
            try:
                _run_one_auto_cycle()
            finally:
                pass


# ------------ Flask application ------------
tmpl_dir = "templates" if os.path.isdir("templates") else "."
app = Flask(__name__, static_folder="static", template_folder=tmpl_dir)


@app.route("/")
def index():
    """Serve templates/index.html if present; otherwise serve index.html from CWD."""
    if os.path.isfile(os.path.join(tmpl_dir, "index.html")):
        return render_template("index.html")
    return send_from_directory(".", "index.html")


@app.route("/sensors", methods=["GET"])
def get_sensors():
    """
    Return current humidity readings for all sensors.

    On read errors, the endpoint falls back to the last cached value in 'last_pct'
    (if available) for the corresponding sensor to keep the API stable.
    """
    pct = []
    for s in sensor_devices:
        try:
            pct.append(round(float(s.get_humidity(AVG_READINGS)), 1))
        except Exception as e:
            print(f"[api] sensor read err @ {getattr(s, 'channel', '?')}: {e}", file=sys.stderr)
            with _state_lock:
                idx = len(pct)
                pct.append(last_pct[idx] if idx < len(last_pct) else None)

    with _state_lock:
        last_pct[:] = pct

    return jsonify({
        "percent": pct,
        "cached": False,
        "auto": _auto_enabled_evt.is_set()
    })


# ========= one-shot read & log (no watering) =========
@app.route("/read_and_log", methods=["POST"])
def read_and_log():
    """
    Read all sensors once and write results into Firebase (history/plant_X) with the
    server's local-time ISO timestamp. This endpoint ONLY logs data; it does not perform
    watering or make watering decisions. Returns the array of readings and the timestamp.
    """
    pct = []
    for s in sensor_devices:
        try:
            h = round(float(s.get_humidity(AVG_READINGS)), 1)
        except Exception as e:
            print(f"[api] read_and_log sensor read err @ {getattr(s, 'channel', '?')}: {e}", file=sys.stderr)
            h = None
        pct.append(h)

    with _state_lock:
        last_pct[:] = pct

    try:
        _firebase_log_readings(pct)
    except Exception as e:
        print(f"[api] read_and_log firebase log err: {e}")

    return jsonify({
        "status": "success",
        "percent": pct,
        "timestamp": iso_now_local()
    })


@app.route("/pump/<int:pump_id>", methods=["POST"])
def pump_control(pump_id: int):
    """
    Turn on a specific pump (1-based) for a bounded duration.

    Body:
      { "duration": float seconds }  # clamped to [0.5, 60.0]
    """
    if not (1 <= pump_id <= len(pumps)):
        return jsonify({"status": "error", "message": "Invalid pump ID"}), 400

    data = request.get_json(silent=True) or {}
    try:
        duration = float(data.get("duration", 3))
    except Exception:
        return jsonify({"status": "error", "message": "Invalid duration"}), 400
    duration = max(0.5, min(60.0, duration))
    idx = pump_id - 1

    try:
        mode = hold.hold(idx, duration, source="manual")
    except Exception as e:
        return jsonify({"status": "error", "message": f"Pump ON failed: {e}"}), 500

    return jsonify({
        "status": "success",
        "mode": mode,
        "message": f"Pump {pump_id} will stay ON for {duration} s from now"
    })


@app.route("/pump/<int:pump_id>/off", methods=["POST"])
def pump_off(pump_id: int):
    """
    Immediately stop a specific pump (1-based).
    Returns whether the pump was previously ON and the new state.
    """
    if not (1 <= pump_id <= len(pumps)):
        return jsonify({"status": "error", "message": "Invalid pump ID"}), 400
    idx = pump_id - 1

    was_on = hold.is_on(idx)
    ok = hold.off(idx, source="manual-stop")
    return jsonify({
        "status": "success" if ok else "noop",
        "message": f"Pump {pump_id} {'stopped' if ok else 'was already off'}",
        "was_on": was_on,
        "remaining": 0.0
    })


@app.route("/pump/off_all", methods=["POST"])
def pump_off_all():
    """Emergency stop: immediately turn OFF all pumps."""
    try:
        hold.off_all(source="emergency")
    except Exception as e:
        return jsonify({"status": "error", "message": f"off_all failed: {e}"}), 500

    return jsonify({"status": "success", "message": "All pumps stopped"})


@app.route("/config", methods=["GET", "POST"])
def config_endpoint():
    """
    GET: return current config (the entire JSON as the server sees it)
    POST: update config (whitelist keys only); persists to disk and updates globals
    """
    global cfg, THRESHOLD, AUTO_WATER_SEC, AVG_READINGS, PLANT_THRESHOLDS, FIREBASE_DB_BASE, LOG_PERIOD_SEC

    if request.method == "GET":
        return jsonify(cfg)

    data = request.get_json(force=True, silent=True) or {}

    allowed_keys = [
        "AVG_READINGS", "THRESHOLD", "AUTO_WATER_SEC",
        "FIREBASE_DB_BASE", "LOG_PERIOD_SEC"
    ]
    updated = False
    for key in allowed_keys:
        if key in data:
            cfg[key] = data[key]
            updated = True

    if updated:
        try:
            with open(CONFIG_PATH, "w") as f:
                json.dump(cfg, f, indent=2)

            THRESHOLD = cfg.get("THRESHOLD", THRESHOLD)
            AUTO_WATER_SEC = cfg.get("AUTO_WATER_SEC", AUTO_WATER_SEC)
            AVG_READINGS = cfg.get("AVG_READINGS", AVG_READINGS)
            LOG_PERIOD_SEC = int(cfg.get("LOG_PERIOD_SEC", LOG_PERIOD_SEC))
            if "FIREBASE_DB_BASE" in cfg:
                FIREBASE_DB_BASE = str(cfg["FIREBASE_DB_BASE"]).rstrip("/")
        except Exception as e:
            return jsonify({"status": "error", "message": str(e)}), 500

    return jsonify({"status": "success", "updated": updated, "config": cfg})


@app.route("/auto", methods=["GET", "POST"])
def auto_endpoint():
    """
    GET: return current auto-watering enabled state
    POST: set auto-watering enabled state (expects boolean 'enabled')
    """
    global AUTO_ENABLED, cfg

    if request.method == "GET":
        return jsonify({"enabled": _auto_enabled_evt.is_set()})

    data = request.get_json(silent=True) or {}
    if "enabled" not in data or type(data["enabled"]) is not bool:
        return jsonify({"status": "error", "message": "expected boolean 'enabled'"}), 400

    AUTO_ENABLED = data["enabled"]
    if AUTO_ENABLED:
        _auto_enabled_evt.set()
    else:
        _auto_enabled_evt.clear()

    print(f"[auto] set enabled={AUTO_ENABLED}")

    cfg["AUTO_ENABLED"] = AUTO_ENABLED
    try:
        save_config(cfg)
    except Exception as e:
        return jsonify({"status": "error", "message": f"save failed: {e}"}), 500

    return jsonify({"status": "success", "enabled": AUTO_ENABLED})


# --------- per-plant thresholds API (persisted) ---------
@app.route("/thresholds", methods=["GET"])
def get_thresholds():
    """Return per-plant thresholds from memory (kept in sync with config.json)."""
    with _state_lock:
        arr = list(PLANT_THRESHOLDS)
        gf = float(THRESHOLD)
    return jsonify({"thresholds": arr, "global_fallback": gf, "count": len(arr)})


@app.route("/thresholds/<int:plant_id>", methods=["POST"])
def set_threshold(plant_id: int):
    """
    Update the threshold for a single plant (1-based index) and persist immediately.
    Body:
      { "threshold": number in 0..100 }
    """
    global PLANT_THRESHOLDS, cfg
    data = request.get_json(silent=True) or {}
    try:
        val = float(data.get("threshold", None))
    except Exception:
        return jsonify({"status": "error", "message": "invalid threshold"}), 400

    if not (0.0 <= val <= 100.0):
        return jsonify({"status": "error", "message": "threshold must be 0..100"}), 400

    with _state_lock:
        if not (1 <= plant_id <= len(PLANT_THRESHOLDS)):
            return jsonify({"status": "error", "message": "invalid plant_id"}), 400
        PLANT_THRESHOLDS[plant_id - 1] = val
        cfg["PLANT_THRESHOLDS"] = PLANT_THRESHOLDS[:]

    try:
        save_config(cfg)
    except Exception as e:
        return jsonify({"status": "error", "message": f"save failed: {e}"}), 500

    return jsonify({"status": "success", "plant_id": plant_id, "threshold": val})


@app.route('/img/<path:filename>')
def serve_image(filename):
    """Serve images from the ./img directory."""
    return send_from_directory('img', filename)


@app.after_request
def no_cache(resp):
    """
    Disable HTTP caching for time-sensitive endpoints to ensure fresh data is delivered.
    Targets: /sensors, /read_and_log, /auto
    """
    if request.path.startswith('/sensors') or request.path.startswith('/read_and_log') or request.path.startswith('/auto'):
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
    return resp


# ------------ main entrypoint ------------
def _print_startup_info():
    """Print configuration highlights for easier diagnostics at boot."""
    with _state_lock:
        print(f"[boot] per-plant thresholds: {PLANT_THRESHOLDS}")
        print(f"[boot] FIREBASE_DB_BASE: {FIREBASE_DB_BASE}")
        print(f"[boot] LOG_PERIOD_SEC: {LOG_PERIOD_SEC} (every {LOG_PERIOD_SEC/60:.1f} min)")


atexit.register(_cleanup)  # Ensure GPIO and pump resources are released on exit

if __name__ == "__main__":
    _seed_cache()
    _print_startup_info()
    print(f"Cached initial humidity: {last_pct}")
    threading.Thread(target=auto_watering, daemon=True).start()

    # Disable Flask debug and reloader to keep background threads safe and single-run
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)
